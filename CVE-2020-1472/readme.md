# TP - Zerologon

## Source

Le PoC est basé sur le document suivant ![Zerologon.pdf](https://www.secura.com/uploads/whitepapers/Zerologon.pdf)

## Trame - PoC

## Etape 1 : Spoofing des identifiants du client

Après un échange de challenges via un appel à `NetrServerReqChallenge`, le client s'authentifie via un appel à `NetrServerAuthenticate3`.

Cet appel prend en paramètre `ClientCredential` qui est obtenu en appliquant le `ComputeNetLogonCredential` au challenge du client qui a été envoyé dans l'appel précédent.

Ce challenge peut être choisis arbitrairement par nous, il n'y a donc rien qui nous empêche de mettre un challenge avec 8 zéros. Cela veut dire que pour une session sur 256, le `ClientCredential` correcte consistera aussi de 8 zéros.

Comment savoir si notre clé comporte bien 8 zéros ? Nous ne pouvons pas.
Etant donné que les comptes d'ordinateurs ne sont pas bloqués lors de connexion échoué, nous pouvons testé jusqu'à ce qu'une authentification soit valide.
En théorie il faut 256 essaies, ce qui prend environ 3 secondes.

Avec cette méthode nous pouvons nous connecter avec n'importe quel compte ordinateur, cela inclus le controlleur de domaine lui-même.

## Etape 2 : Désactivation de la signature et ?sealing?

La première étape, nous permet de bypass l'appel à l'authentification mais nous avons toujours aucune idée de la valeur de la clé de session. Cela est problèmatique car Netlogon (`RPC signing and sealing`) utilise cette clé.

Heureusement pour nous, `signing and sealing` est optionnel est peut être désactivé tout simplement en ne mettant pas un flag lors de l'appel à `NetrServerAuthenticate3`. Les clients modernes refusent la connexion lorsque ce flag n'est pas pour éviter les attaques par downgrade. Mais les serveurs acceptent les requêtes sans chiffrement.

Nous pouvons donc oublier ce flag et continuer.

## Etape 3 : Spoof un appel

Même quand les échanges ne sont pas chiffrés, ils ont besoin de contenir un `authenticator`. Cette valeur est obtenu en appliquant la clé de session via `ComputeNetlogonCredential` avec les valeurs de `ClientStoredCredential` concaténé avec le `Timestamp`.

`ClientStoredCredential` est incrémenté et maintenu par le client. Lors du handshake, elle est initialisé avec la même valeur que le `ClientCredential` que nous avons envoyé. Les identifiants du client étant 0, `ClientStoredCredential` sera donc 0 pour le première appel à l'authentification.

`Timestamp` doit contenir le temps Posix. Le serveur ne vérifie pas cette valeur, il est donc possible de mettre cette valeur à 0 pour faire sembler qu'on est le 1ier Janvier 1970.

Si nous passons la première étape, nous savons que `ComputeNetlogonCredential(0) = 0`. Donc nous pouvons nous connecter la première fois avec un `authenticator` et un `timestamp` à 0.

## Etape 4 : Changer le mot de passe du compte ordinateur du controleur de domaine

Maintenant, nous pouvons envoyé un appel Netlogon à tous les ordinateurs.
Un appel intéressant est `NetrServerPasswordSet2` qui permet de définir un nouveau mot de passe chiffré avec la clé de session.
En envoyant 516 zeros, le serveur va déchiffré et se retrouver avec 516 zeros. Les 4 derniers bytes indiquant la taille du mot de passe, cela veut dire que le mot de passe sera vide aux yeux du controleur de domaine. Un mot de passe vide n'étant pas interdit pour un ordinateur, cela veut dire que l'on peut changer tous les mots de passes des comptes ordinateurs du domaine.

En suivant cette trame, le mot de passe sera uniquement changé sur le controleur de domaine. Pour les autres machines qui garde une copie sur leur système local, ils ne seront plus capables de ce connecter au controleur de domaine. Ils peuvent cependant être resynchornisé de manière manuelle.

Cela cause un DOS.

## Etape 5 : De changement de mot de passe vers Administreurs du domaine

Un des ordinateurs pour lequel on peut changer le mot de passe est le compte ordinateur du controleur de domaine. Etant donné que le mot de passe du DC est stocké et celui de l'AD est stockée est différent, cela cause quelques problèmes nottamment le DNS qui arrête de fonctionner.

En tant qu'attaquant, nous pouvons nous servir de ça pour nous connecter au controleur de domaine compromis.
